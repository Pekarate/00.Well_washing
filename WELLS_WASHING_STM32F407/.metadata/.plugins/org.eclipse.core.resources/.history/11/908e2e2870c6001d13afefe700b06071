/*
 * motor.c
 *
 *  Created on: Mar 19, 2023
 *      Author: ADMIN
 */


#include "main.h"
#include "stdint.h"
#include "motor.h"
#include "stdlib.h"

extern TIM_HandleTypeDef htim1;
extern TIM_HandleTypeDef htim2;
_motor_typedef x_motor,z_motor;

void x_mt_set_dir(uint32_t cur_pos,uint32_t next_pos){
//	x_motor.current_dir = dir;
	if(cur_pos < next_pos){
		HAL_GPIO_WritePin(X_MOTOR_DIR_GPIO_Port, X_MOTOR_DIR_Pin, DIR_FORWARD);
		htim2.Instance->CR1 &= ~(1<<4);
	}
	else
	{
		HAL_GPIO_WritePin(X_MOTOR_DIR_GPIO_Port, X_MOTOR_DIR_Pin, DIR_BACKWARD);
		htim2.Instance->CR1 |= (1<<4);
	}

}


void x_mt_start(){
	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
}

void x_mt_stop()
{
	HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_1);
}

void x_mt_move_to_pos(uint32_t pos){
	x_motor.next_pos = pos;
	x_motor.current_pos = htim2.Instance->CNT;
	HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_1);
	x_mt_set_dir(x_motor.current_pos,x_motor.next_pos);
}

void step_motor_process(_motor_typedef st_motor)
{
	x_motor.current_pos = htim2.Instance->CNT;
	switch (st_motor.state) {
		case MT_STATE_IDLE:
			if(abs(st_motor.current_pos- st_motor.next_pos) > STEP_LOSS){
				stmotor.state = MT_STATE_START;
			}
			break;
		case MT_STATE_START:
			st_motor->mt_start();
			st_motor.state = MT_STATE_RUNING;
			break;
		case MT_STATE_RUNING:
			st_motor->mt_start();
			st_motor.state = MT_STATE_RUNING;
			break;
		default:
			break;
	}
}
