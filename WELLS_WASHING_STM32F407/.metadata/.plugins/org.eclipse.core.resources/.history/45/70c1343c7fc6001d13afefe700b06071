/*
 * dw_display.c
 *
 *  Created on: Mar 18, 2023
 *      Author: ADMIN
 */


#include "main.h"
#include "uart.h"
#include "string.h"
#include "data.h"
#include "dw_display.h"
#include "motor.h"

uint8_t	current_rx_index = 0;
uint8_t *dw_rx_buf[10] = {0};



static inline void Dw_write(uint8_t *data,uint16_t len)
{
	uart_transmit_block(data, len, 1000);
}

int Dwin_Write_VP(uint16_t Addr,uint16_t *data,uint16_t len)
{
	uint8_t DwinBuf[100];
	DwinBuf[0]= 0x5A;
	DwinBuf[1]= 0xA5;
	DwinBuf[2]= (len+1)*2 +1;  //
	DwinBuf[3]= 0x82;
	DwinBuf[4]= Addr>>8;
	DwinBuf[5]= Addr;
	for(int i=0;i<len;i++)
	{
		DwinBuf[6+i*2] = data[i]/256;
		DwinBuf[6+i*2+1] = data[i];
	}
    len = (len+1)*2 +4;
    Dw_write(DwinBuf, len);
	return 1;
}
int Dwin_read_VP(uint16_t Addr,uint16_t *data,uint16_t len)
{
	uint8_t DwinBuf[100] ={0x5A,0xA5};
	DwinBuf[2]= 0x04;  //
	DwinBuf[3]= 0x83;
	DwinBuf[4]= Addr>>8;
	DwinBuf[5]= Addr;
    len = (len+1)*2 +4;
    Dw_write(DwinBuf, len);
	return 1;
}
void Dwin_switch_page(int page_index)
{
	uint16_t Buf[2] = {0x5A01,00};
	Buf[1] = page_index;
	Dwin_Write_VP(0X0084,Buf,2);
}
void Dwin_reset(void)
{
	uint16_t Buf[2] = {0x55AA,0x5AA5};
	Dwin_Write_VP(0X0004,Buf,2);
}

int dw_update_setup_page(uint8_t pg,uint8_t stepnumber){
	if((pg < 1 ) || (stepnumber <1)){
			return -1;
	}
	uint16_t data[10];

	data[0] = pg;
	data[1] = stepnumber;
	data[2] = system_data.flash_data.Program_para[pg-1][stepnumber-1].type;
	data[3] = system_data.flash_data.Program_para[pg-1][stepnumber-1].wells;
	for(int i=4;i<10;i++)
	{
		data[i] = system_data.flash_data.Program_para[pg-1][stepnumber-1].timing[i-4];
	}
	Dwin_Write_VP(VP_SETUP_PARA,data,10);
	return 1;
}

void show_setup_page(uint8_t pg,uint8_t stepnumber){
	if((pg < 1 ) || (stepnumber <1)){
		return;
	}
	switch(system_data.flash_data.Program_para[pg-1][stepnumber-1].type){
		case (STEP_TYPE_NONE):
				Dwin_switch_page(PAGE_SETUP_STEP_NONE);
				break;
		case (STEP_TYPE_SHAKE):
				Dwin_switch_page(PAGE_SETUP_STEP_SHAKE);
				break;
		case (STEP_TYPE_WASHING):
				Dwin_switch_page(PAGE_SETUP_STEP_WASHING);
				break;
		case (STEP_TYPE_DRYING):
				Dwin_switch_page(PAGE_SETUP_STEP_DRYING);
				break;
	}
	dw_update_setup_page(pg,stepnumber);
}
//                 2F  FF      2F FF   30  00
//                                  8      10  11  12  13 14  15  16
//{5A}{A5}{18}{83}{3A}{00}{0A}{00}{00}{00}{01}{00}{01}{00}{00}{00}{00}{00}{00}{00}{00}{00}{00}{00}{00}{00}{00}
void dwin_update_step(uint8_t *data){
	_def_step step;
	uint8_t pg = data[8]; // 0x3000
	uint8_t stepindex = data[10]; // 0x3001
	step.type  =data[12];
	step.wells =data[14];
	for(int i=0;i<6;i++){
		step.timing[i] = (uint16_t)data[15+i*2]*256 + data[16+i*2];
	}

	dt_Modify_step(pg-1, stepindex-1, step);
}


static uint8_t current_pg_setup;
static uint8_t current_step_setup;
int dw_process_rx_buffer(uint8_t *data,uint16_t size){ //USART_CR2_TOEN

	if(size < 5){
		return -1;
	}
	if(data[0] != 0x5A && data[1] != 0xA5 ){
		return -2;
	}
	uint16_t code = data[4];
	code = code*256+ data[5];
	uint16_t value;
	switch (code) {
		case BT_SETUP_CODE:
				current_pg_setup=value = data[8];
				current_step_setup =1;
				show_setup_page(value,1);
			break;
	case BT_SWICH_SETUP_PAGE:
				current_step_setup = value = data[8];
				show_setup_page(current_pg_setup,value);
			break;
		case BT_SWICH_SETUP_EXIT:
				dw_update_step_numbers();
				current_pg_setup =0;
			break;
		case BT_SWICH_SETUP_APPLY:
				dwin_update_step(data);
				break;
		default:
			break;
	}
	return 1;
}

int dw_update_step_numbers(void){
	dt_calculator_pg_stepnumber();
	Dwin_Write_VP(VP_STEP_NUMBERS,system_data.pg_stepnumber,10);
	return 1;
}

int dw_update_steper_positon(_motor_typedef *st_motor){
	if((st_motor->old_pos != st_motor->current_pos))
	{
		st_motor->old_pos = st_motor->current_pos;
		uint16_t data[4];
		data[0] = st_motor->current_pos/65535;
		data[1] = st_motor->current_pos;
		data[2] = st_motor->next_pos/65535;
		data[3] = st_motor->next_pos;
		Dwin_Write_VP(VP_X_STEP_MOTOR,data,4);
		return 1;
	}
	return 0;
}

